// Generated by CoffeeScript 1.4.0
(function() {
  var Database, Profile, deck, fs, inspect, isString, ngramize, pretty, wait,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  inspect = require('util').inspect;

  fs = require('fs');

  deck = require('deck');

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  wait = function(t) {
    return function(f) {
      return setTimeout(f, t);
    };
  };

  ngramize = function(words, n) {
    var gram, grams, i, k, subgrams, v, w, _i, _j, _len, _ref;
    if (!Array.isArray(words)) {
      words = words.split(' ');
    }
    grams = {};
    if (n < 2) {
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        w = words[_i];
        grams["" + w] = Array.isArray(w) ? w : [w];
      }
      return grams;
    }
    for (i = _j = 0, _ref = words.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      gram = words.slice(i, i + n);
      subgrams = ngramize(gram, n - 1);
      for (k in subgrams) {
        v = subgrams[k];
        grams[k] = v;
      }
      if (i > words.length - n) {
        break;
      }
      grams["" + gram] = gram;
    }
    return grams;
  };

  Database = (function() {

    function Database(input) {
      this.toString = __bind(this.toString, this);

      this.toFile = __bind(this.toFile, this);

      this.prune = __bind(this.prune, this);

      this.tag = __bind(this.tag, this);

      this.learn = __bind(this.learn, this);

      var rawData;
      this._ = {};
      if (input != null) {
        if (isString(input)) {
          rawData = "{}";
          try {
            rawData = fs.readFileSync(input);
            console.log("loaded file " + input);
          } catch (e) {
            console.log("couldn't read input file, will create a new one");
          }
          this._ = JSON.parse("" + rawData);
        } else {
          this._ = input;
        }
      }
      this.ngramSize = 3;
      this.length = Object.keys(this._).length;
      this.size = rawData.length;
    }

    Database.prototype.learn = function(tagged, b) {
      var key, keywords, n, ngram, txt, _i, _len, _ref, _tagged;
      if (b != null) {
        _tagged = {};
        _tagged["" + tagged] = b;
        tagged = _tagged;
      }
      for (txt in tagged) {
        keywords = tagged[txt];
        _ref = ngramize(txt, this.ngramSize);
        for (n in _ref) {
          ngram = _ref[n];
          if (!(n in this._)) {
            this._[n] = {
              ngram: ngram,
              keywords: {}
            };
          }
          for (_i = 0, _len = keywords.length; _i < _len; _i++) {
            key = keywords[_i];
            if (!(key in this._[n].keywords)) {
              this._[n].keywords[key] = 0;
            }
            this._[n].keywords[key] += 1;
          }
        }
      }
      this.length = Object.keys(this._).length;
      return this;
    };

    Database.prototype.tag = function(untagged, learn) {
      var count, k, keywords, n, ngram, tagged, txt, _i, _len, _ref, _ref1;
      if (learn == null) {
        learn = false;
      }
      if (Array.isArray(untagged)) {
        tagged = {};
        for (_i = 0, _len = untagged.length; _i < _len; _i++) {
          txt = untagged[_i];
          tagged["" + txt] = this.tag(txt);
        }
        if (learn) {
          this.learn(tagged);
        }
        return tagged;
      } else {
        keywords = {};
        _ref = ngramize(untagged, 3);
        for (n in _ref) {
          ngram = _ref[n];
          if (n in this._) {
            _ref1 = this._[n].keywords;
            for (k in _ref1) {
              count = _ref1[k];
              if (!(k in keywords)) {
                keywords[k] = 0;
              }
              keywords[k] += count;
            }
          }
        }
        return keywords;
      }
    };

    Database.prototype.prune = function(filter, onComplete) {
      var count, keyword, ngram, ngrams, p, prunableKeys, prunableKeywords, pruned, _i, _j, _len, _len1, _ref, _ref1;
      pruned = {
        keywords: 0,
        ngrams: 0
      };
      prunableKeywords = [];
      _ref = this._;
      for (ngram in _ref) {
        ngrams = _ref[ngram];
        prunableKeys = [];
        _ref1 = ngrams.keywords;
        for (keyword in _ref1) {
          count = _ref1[keyword];
          if (filter({
            keyword: keyword,
            count: count
          })) {
            prunableKeys.push(keyword);
          }
        }
        for (_i = 0, _len = prunableKeys.length; _i < _len; _i++) {
          p = prunableKeys[_i];
          delete ngrams.keywords[p];
          pruned.keywords += 1;
        }
        if (Object.keys(ngrams.keywords).length === 0) {
          prunableKeywords.push(ngram);
        }
      }
      for (_j = 0, _len1 = prunableKeywords.length; _j < _len1; _j++) {
        p = prunableKeywords[_j];
        delete this._[p];
        pruned.ngrams += 1;
      }
      this.length = Object.keys(this._).length;
      if (onComplete != null) {
        onComplete(pruned);
      } else {
        return pruned;
      }
    };

    Database.prototype.toFile = function(fileName, onComplete) {
      return fs.writeFile(fileName, "" + this, function(err) {
        if (err) {
          throw err;
        }
        console.log('It\'s saved!');
        return typeof onComplete === "function" ? onComplete() : void 0;
      });
    };

    Database.prototype.toString = function() {
      var dump;
      dump = JSON.stringify(this._, null, 2);
      this.size = dump.length;
      return dump;
    };

    return Database;

  })();

  Profile = (function() {

    function Profile(_) {
      this._ = _ != null ? _ : {};
      this.recommend = __bind(this.recommend, this);

      this.guess = __bind(this.guess, this);

      this.learn = __bind(this.learn, this);

    }

    Profile.prototype.learn = function(txt, keywords, choice) {
      var value, word, _results;
      if (keywords == null) {
        keywords = [];
      }
      if (choice == null) {
        choice = 0;
      }
      _results = [];
      for (word in keywords) {
        value = keywords[word];
        if (!(word in this._)) {
          this._[word] = {
            weight: 0,
            count: 0
          };
        }
        this._[word].weight += choice;
        _results.push(this._[word].count += 1);
      }
      return _results;
    };

    Profile.prototype.guess = function(txt, keywords) {
      var confidence, count, finalScore, keyword, maxConfidence, size, tmp, weight;
      if (txt == null) {
        txt = "";
      }
      if (keywords == null) {
        keywords = [];
      }
      maxConfidence = 0;
      tmp = {};
      for (keyword in keywords) {
        confidence = keywords[keyword];
        if (keyword in this._) {
          tmp[keyword] = confidence;
          if (confidence > maxConfidence) {
            maxConfidence = confidence;
          }
        }
      }
      keywords = tmp;
      size = Object.keys(keywords).length;
      finalScore = 0;
      for (keyword in keywords) {
        confidence = keywords[keyword];
        count = this._[keyword].count;
        weight = this._[keyword].weight;
        finalScore += (confidence / maxConfidence) * (weight / count);
      }
      finalScore /= size;
      if (!isFinite(finalScore)) {
        finalScore = 0;
      }
      console.log("final score: " + pretty(finalScore));
      return finalScore;
    };

    Profile.prototype.recommend = function(tagged) {
      var i, keywords, score, tmp, txt, _i, _len, _results;
      if (tagged == null) {
        tagged = [];
      }
      tmp = (function() {
        var _results;
        _results = [];
        for (txt in tagged) {
          keywords = tagged[txt];
          score = this.guess(txt, keywords);
          _results.push([txt, (1 + score) * 0.5]);
        }
        return _results;
      }).call(this);
      tmp.sort(function(a, b) {
        return b[1] - a[1];
      });
      _results = [];
      for (_i = 0, _len = tmp.length; _i < _len; _i++) {
        i = tmp[_i];
        _results.push({
          txt: i[0],
          score: i[1]
        });
      }
      return _results;
    };

    return Profile;

  })();

  exports.Database = Database;

  exports.Profile = Profile;

}).call(this);
