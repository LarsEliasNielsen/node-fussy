// Generated by CoffeeScript 1.4.0
(function() {
  var Database, Profile, deck, inspect, ngramize, pretty, wait,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  inspect = require('util').inspect;

  deck = require('deck');

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  wait = function(t) {
    return function(f) {
      return setTimeout(f, t);
    };
  };

  ngramize = function(words, n) {
    var gram, grams, i, k, subgrams, v, w, _i, _j, _len, _ref;
    if (!Array.isArray(words)) {
      words = words.split(' ');
    }
    grams = {};
    if (n < 2) {
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        w = words[_i];
        grams["" + w] = Array.isArray(w) ? w : [w];
      }
      return grams;
    }
    for (i = _j = 0, _ref = words.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      gram = words.slice(i, i + n);
      subgrams = ngramize(gram, n - 1);
      for (k in subgrams) {
        v = subgrams[k];
        grams[k] = v;
      }
      if (i > words.length - n) {
        break;
      }
      grams["" + gram] = gram;
    }
    return grams;
  };

  Database = (function() {

    function Database(_) {
      this._ = _ != null ? _ : {};
      this.toString = __bind(this.toString, this);

      this.tag = __bind(this.tag, this);

      this.learn = __bind(this.learn, this);

      this.ngramSize = 3;
    }

    Database.prototype.learn = function(tagged) {
      var key, keywords, n, ngram, txt, _results;
      _results = [];
      for (txt in tagged) {
        keywords = tagged[txt];
        _results.push((function() {
          var _ref, _results1;
          _ref = ngramize(txt, this.ngramSize);
          _results1 = [];
          for (n in _ref) {
            ngram = _ref[n];
            if (!(n in this._)) {
              this._[n] = {
                ngram: ngram,
                keywords: {}
              };
            }
            _results1.push((function() {
              var _i, _len, _results2;
              _results2 = [];
              for (_i = 0, _len = keywords.length; _i < _len; _i++) {
                key = keywords[_i];
                if (!(key in this._[n].keywords)) {
                  this._[n].keywords[key] = 0;
                }
                _results2.push(this._[n].keywords[key] += 1);
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Database.prototype.tag = function(untagged, learn) {
      var count, k, keywords, n, ngram, tagged, txt, _i, _len, _ref, _ref1;
      if (learn == null) {
        learn = false;
      }
      if (Array.isArray(untagged)) {
        tagged = {};
        for (_i = 0, _len = untagged.length; _i < _len; _i++) {
          txt = untagged[_i];
          tagged["" + txt] = this.tag(txt);
        }
        if (learn) {
          this.learn(tagged);
        }
        return tagged;
      } else {
        keywords = {};
        _ref = ngramize(untagged, 3);
        for (n in _ref) {
          ngram = _ref[n];
          if (n in this._) {
            _ref1 = this._[n].keywords;
            for (k in _ref1) {
              count = _ref1[k];
              if (!(k in keywords)) {
                keywords[k] = 0;
              }
              keywords[k] += count;
            }
          }
        }
        return keywords;
      }
    };

    Database.prototype.toString = function() {
      return pretty(this._);
    };

    return Database;

  })();

  Profile = (function() {

    function Profile(_) {
      this._ = _;
      this.recommend = __bind(this.recommend, this);

      this.guess = __bind(this.guess, this);

      this.learn = __bind(this.learn, this);

      this._ = {};
    }

    Profile.prototype.learn = function(txt, keywords, choice) {
      var value, word, _results;
      if (keywords == null) {
        keywords = [];
      }
      if (choice == null) {
        choice = 0;
      }
      _results = [];
      for (word in keywords) {
        value = keywords[word];
        if (!(word in this._)) {
          this._[word] = {
            weight: 0,
            count: 0
          };
        }
        this._[word].weight += choice;
        _results.push(this._[word].count += 1);
      }
      return _results;
    };

    Profile.prototype.guess = function(txt, keywords) {
      var confidence, count, finalScore, keyword, maxConfidence, size, tmp, weight;
      if (txt == null) {
        txt = "";
      }
      if (keywords == null) {
        keywords = [];
      }
      maxConfidence = 0;
      tmp = {};
      for (keyword in keywords) {
        confidence = keywords[keyword];
        if (keyword in this._) {
          tmp[keyword] = confidence;
          if (confidence > maxConfidence) {
            maxConfidence = confidence;
          }
        }
      }
      keywords = tmp;
      size = Object.keys(keywords).length;
      finalScore = 0;
      for (keyword in keywords) {
        confidence = keywords[keyword];
        count = this._[keyword].count;
        weight = this._[keyword].weight;
        finalScore += (confidence / maxConfidence) * (weight / count);
      }
      finalScore /= size;
      if (!isFinite(finalScore)) {
        finalScore = 0;
      }
      console.log("final score: " + pretty(finalScore));
      return finalScore;
    };

    Profile.prototype.recommend = function(tagged) {
      var i, keywords, score, tmp, txt, _i, _len, _results;
      if (tagged == null) {
        tagged = [];
      }
      tmp = (function() {
        var _results;
        _results = [];
        for (txt in tagged) {
          keywords = tagged[txt];
          score = this.guess(txt, keywords);
          _results.push([txt, 1 + score]);
        }
        return _results;
      }).call(this);
      tmp.sort(function(a, b) {
        return b[1] - a[1];
      });
      _results = [];
      for (_i = 0, _len = tmp.length; _i < _len; _i++) {
        i = tmp[_i];
        _results.push({
          txt: i[0],
          score: i[1] - 1
        });
      }
      return _results;
    };

    return Profile;

  })();

  exports.Database = Database;

  exports.Profile = Profile;

}).call(this);
