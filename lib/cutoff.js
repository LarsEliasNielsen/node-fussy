// Generated by CoffeeScript 1.4.0
(function() {
  var Database, Profile, database, deck, inspect, ngramize, pretty, profile, simulation, tagged, training, untagged, userFeedback, wait,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  inspect = require('util').inspect;

  deck = require('deck');

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  wait = function(t) {
    return function(f) {
      return setTimeout(f, t);
    };
  };

  ngramize = function(words, n) {
    var gram, grams, i, k, subgrams, v, w, _i, _j, _len, _ref;
    if (!Array.isArray(words)) {
      words = words.split(' ');
    }
    grams = {};
    if (n < 2) {
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        w = words[_i];
        grams["" + w] = Array.isArray(w) ? w : [w];
      }
      return grams;
    }
    for (i = _j = 0, _ref = words.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      gram = words.slice(i, i + n);
      subgrams = ngramize(gram, n - 1);
      for (k in subgrams) {
        v = subgrams[k];
        grams[k] = v;
      }
      if (i > words.length - n) {
        break;
      }
      grams["" + gram] = gram;
    }
    return grams;
  };

  Database = (function() {

    function Database(_) {
      this._ = _ != null ? _ : {};
      this.toString = __bind(this.toString, this);

      this.tag = __bind(this.tag, this);

      this.learn = __bind(this.learn, this);

      this.ngramSize = 3;
    }

    Database.prototype.learn = function(tagged) {
      var key, keywords, n, ngram, txt, _results;
      _results = [];
      for (txt in tagged) {
        keywords = tagged[txt];
        _results.push((function() {
          var _ref, _results1;
          _ref = ngramize(txt, this.ngramSize);
          _results1 = [];
          for (n in _ref) {
            ngram = _ref[n];
            if (!(n in this._)) {
              this._[n] = {
                ngram: ngram,
                keywords: {}
              };
            }
            _results1.push((function() {
              var _i, _len, _results2;
              _results2 = [];
              for (_i = 0, _len = keywords.length; _i < _len; _i++) {
                key = keywords[_i];
                if (!(key in this._[n].keywords)) {
                  this._[n].keywords[key] = 0;
                }
                _results2.push(this._[n].keywords[key] += 1);
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Database.prototype.tag = function(untagged, learn) {
      var count, k, keywords, n, ngram, tagged, txt, _i, _len, _ref, _ref1;
      if (learn == null) {
        learn = false;
      }
      if (Array.isArray(untagged)) {
        tagged = {};
        for (_i = 0, _len = untagged.length; _i < _len; _i++) {
          txt = untagged[_i];
          tagged["" + txt] = this.tag(txt);
        }
        if (learn) {
          this.learn(tagged);
        }
        return tagged;
      } else {
        keywords = {};
        _ref = ngramize(untagged, 3);
        for (n in _ref) {
          ngram = _ref[n];
          if (n in this._) {
            _ref1 = this._[n].keywords;
            for (k in _ref1) {
              count = _ref1[k];
              if (!(k in keywords)) {
                keywords[k] = 0;
              }
              keywords[k] += count;
            }
          }
        }
        return keywords;
      }
    };

    Database.prototype.toString = function() {
      return pretty(this._);
    };

    return Database;

  })();

  Profile = (function() {

    function Profile(_) {
      this._ = _;
      this.recommend = __bind(this.recommend, this);

      this.guess = __bind(this.guess, this);

      this.learn = __bind(this.learn, this);

      this._ = {};
    }

    Profile.prototype.learn = function(txt, keywords, choice) {
      var value, word, _results;
      if (keywords == null) {
        keywords = [];
      }
      if (choice == null) {
        choice = 0;
      }
      _results = [];
      for (word in keywords) {
        value = keywords[word];
        if (!(word in this._)) {
          this._[word] = {
            weight: 0,
            count: 0
          };
        }
        this._[word].weight += choice;
        _results.push(this._[word].count += 1);
      }
      return _results;
    };

    Profile.prototype.guess = function(txt, keywords) {
      var confidence, count, finalScore, keyword, maxConfidence, size, tmp, weight;
      if (txt == null) {
        txt = "";
      }
      if (keywords == null) {
        keywords = [];
      }
      maxConfidence = 0;
      tmp = {};
      for (keyword in keywords) {
        confidence = keywords[keyword];
        if (keyword in this._) {
          tmp[keyword] = confidence;
          if (confidence > maxConfidence) {
            maxConfidence = confidence;
          }
        }
      }
      keywords = tmp;
      size = Object.keys(keywords).length;
      finalScore = 0;
      for (keyword in keywords) {
        confidence = keywords[keyword];
        count = this._[keyword].count;
        weight = this._[keyword].weight;
        finalScore += (confidence / maxConfidence) * (weight / count);
      }
      finalScore /= size;
      if (!isFinite(finalScore)) {
        finalScore = 0;
      }
      console.log("final score: " + pretty(finalScore));
      return finalScore;
    };

    Profile.prototype.recommend = function(tagged) {
      var i, keywords, score, tmp, txt, _i, _len, _results;
      if (tagged == null) {
        tagged = [];
      }
      tmp = (function() {
        var _results;
        _results = [];
        for (txt in tagged) {
          keywords = tagged[txt];
          score = this.guess(txt, keywords);
          _results.push([txt, 1 + score]);
        }
        return _results;
      }).call(this);
      tmp.sort(function(a, b) {
        return b[1] - a[1];
      });
      _results = [];
      for (_i = 0, _len = tmp.length; _i < _len; _i++) {
        i = tmp[_i];
        _results.push({
          txt: i[0],
          score: i[1] - 1
        });
      }
      return _results;
    };

    return Profile;

  })();

  database = new Database();

  training = {
    "Twitter to sue Google over twitter stream monetization": ["Technology", "Twitter", "Google", "Internet"],
    "A new library open in the east center in NYC": ["city", "library", "nyc"],
    "Rumors: Apple to launch a new tablet for emerging markets": ["Technology", "Apple", "Rumor"],
    "Microsoft reveal its new data center": ["Technology", "Rumor", "Microsoft"],
    "An energy-friendly data center for emerging countries": ["Technology", "World", "Energy"],
    "History of the countries: world music festival at the museum": ["Music", "City", "Culture"],
    "Visiting a museum is good for health": ["Health", "Culture"],
    "Using home brew to install appplications on your Apple macbook": ["Computers", "Software", "Apple"],
    "How to brew your own beer": ["DIY", "Fooding", "Beverages", "Beer"],
    "Facebook to reveal a new open source library": ["Opensource", "Technology", "Facebook", "Social Networks"],
    "Open source conference give free beer to first 50 people in NY": ["Opensource", "Beer", "Conference", "City"],
    "What is in people's head? an in-depth data analysis": ["Psychology"]
  };

  database.learn(training);

  console.log(database.toString());

  untagged = ["Visit the NYC museum using your tablet", "How to brew your own coffee", "Google to launch a new museum app", "Apple to sue Microsoft"];

  tagged = database.tag(untagged);

  console.log("tagged: " + pretty(tagged));

  userFeedback = function(txt, keywords, feedback) {
    var choice;
    console.log(" --> " + (pretty(txt)) + " (MORE) (LESS)");
    choice = Math.round(Math.random() * 2 - 1);
    return wait(100)(function() {
      return feedback(txt, keywords, choice);
    });
  };

  profile = new Profile();

  (simulation = function() {
    var keys, keywords, recommended, txt;
    recommended = profile.recommend(tagged);
    console.log("recommendations: " + pretty(recommended));
    keys = Object.keys(tagged);
    txt = keys[Math.round(Math.random() * (keys.length - 1))];
    keywords = tagged[txt];
    if (!txt) {
      console.log("nothing to show");
      wait(100)(simulation);
      return;
    }
    userFeedback(txt, keywords, function(txt, keywords, choice) {
      var choiceStr;
      choiceStr = {
        '1': 'LIKE',
        '-1': 'DISLIKE',
        '0': 'IGNORE'
      }[choice.toString()];
      console.log(" <-- user choose to " + choiceStr);
      if (choice === 0) {
        console.log("do nothing for " + pretty(txt));
        return;
      }
      return profile.learn(txt, keywords, choice);
    });
    return wait(200)(simulation);
  })();

}).call(this);
