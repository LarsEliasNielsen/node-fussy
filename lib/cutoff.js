// Generated by CoffeeScript 1.4.0
(function() {
  var computeInterestScore, computeScores, createDatabaseFromDataset, database, deck, enrichData, enrichedData, inspect, mode, ngramize, pretty, profile, rawData, scoredData, seen, simulation, sortScoredData, trainingDataset, userFeedback, wait;

  inspect = require('util').inspect;

  deck = require('deck');

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  wait = function(t) {
    return function(f) {
      return setTimeout(f, t);
    };
  };

  trainingDataset = {
    "Twitter to sue Google over twitter stream monetization": ["Technology", "Twitter", "Google", "Internet"],
    "A new library open in the east center in NYC": ["city", "library", "nyc"],
    "Rumors: Apple to launch a new tablet for emerging markets": ["Technology", "Apple", "Rumor"],
    "Microsoft reveal its new data center": ["Technology", "Rumor", "Microsoft"],
    "An energy-friendly data center for emerging countries": ["Technology", "World", "Energy"],
    "History of the countries: world music festival at the museum": ["Music", "City", "Culture"],
    "Visiting a museum is good for health": ["Health", "Culture"],
    "Using home brew to install appplications on your Apple macbook": ["Computers", "Software", "Apple"],
    "How to brew your own beer": ["DIY", "Fooding", "Beverages", "Beer"],
    "Facebook to reveal a new open source library": ["Opensource", "Technology", "Facebook", "Social Networks"],
    "Open source conference give free beer to first 50 people in NY": ["Opensource", "Beer", "Conference", "City"],
    "What is in people's head? an in-depth data analysis": ["Psychology"]
  };

  ngramize = function(words, n) {
    var gram, grams, i, k, subgrams, v, w, _i, _j, _len, _ref;
    if (!Array.isArray(words)) {
      words = words.split(' ');
    }
    grams = {};
    if (n < 2) {
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        w = words[_i];
        grams["" + w] = Array.isArray(w) ? w : [w];
      }
      return grams;
    }
    for (i = _j = 0, _ref = words.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      gram = words.slice(i, i + n);
      subgrams = ngramize(gram, n - 1);
      for (k in subgrams) {
        v = subgrams[k];
        grams[k] = v;
      }
      if (i > words.length - n) {
        break;
      }
      grams["" + gram] = gram;
    }
    return grams;
  };

  createDatabaseFromDataset = function(set, size) {
    var db, key, keywords, n, ngram, txt, _i, _len, _ref;
    if (size == null) {
      size = 3;
    }
    db = {};
    for (txt in set) {
      keywords = set[txt];
      _ref = ngramize(txt, size);
      for (n in _ref) {
        ngram = _ref[n];
        if (!(n in db)) {
          db[n] = {
            ngram: ngram,
            keywords: {}
          };
        }
        for (_i = 0, _len = keywords.length; _i < _len; _i++) {
          key = keywords[_i];
          if (!(key in db[n].keywords)) {
            db[n].keywords[key] = 0;
          }
          db[n].keywords[key] += 1;
        }
      }
    }
    return db;
  };

  enrichData = function(db, raw, weighted) {
    var enriched, getAllKeywords, guessTopKeywords, title, top, _i, _len;
    if (weighted == null) {
      weighted = false;
    }
    getAllKeywords = function(db, txt) {
      var grams, keyword, keywords, ngramArray, ngramString, value, _ref;
      grams = ngramize(title, 3);
      keywords = {};
      for (ngramString in grams) {
        ngramArray = grams[ngramString];
        if (ngramString in db) {
          _ref = db[ngramString].keywords;
          for (keyword in _ref) {
            value = _ref[keyword];
            if (!(keyword in keywords)) {
              keywords[keyword] = 0;
            }
            keywords[keyword] += value;
          }
        }
      }
      return keywords;
    };
    guessTopKeywords = function(db, txt, maxKeywords, minWeight) {
      var keyword, keywords, top, weight;
      if (maxKeywords == null) {
        maxKeywords = 3;
      }
      if (minWeight == null) {
        minWeight = 2;
      }
      keywords = getAllKeywords(db, txt);
      top = [];
      for (keyword in keywords) {
        weight = keywords[keyword];
        if (weight < minWeight) {
          continue;
        }
        if (top.length >= maxKeywords) {
          break;
        }
        top.push(keyword);
      }
      return top;
    };
    enriched = {};
    for (_i = 0, _len = raw.length; _i < _len; _i++) {
      title = raw[_i];
      top = [];
      if (weighted) {
        top = getAllKeywords(db, title);
      } else {
        top = guessTopKeywords(db, title);
      }
      console.log("top: " + pretty(top));
      enriched["" + title] = top;
    }
    return enriched;
  };

  computeInterestScore = function(txt, keywords, profile) {
    var confidence, count, finalScore, keptKeywords, keyword, maxConfidence, size, weight;
    maxConfidence = 0;
    keptKeywords = {};
    for (keyword in keywords) {
      confidence = keywords[keyword];
      if (keyword in profile) {
        keptKeywords[keyword] = confidence;
        if (confidence > maxConfidence) {
          maxConfidence = confidence;
        }
      }
    }
    keywords = keptKeywords;
    size = Object.keys(keywords).length;
    finalScore = 0;
    for (keyword in keywords) {
      confidence = keywords[keyword];
      count = profile[keyword].count;
      weight = profile[keyword].weight;
      finalScore += (confidence / maxConfidence) * (weight / count);
    }
    finalScore /= size;
    if (!isFinite(finalScore)) {
      finalScore = 0;
    }
    console.log("final score: " + pretty(finalScore));
    return finalScore;
  };

  computeScores = function(db, data, profile) {
    var keywords, result, score, txt;
    result = {};
    for (txt in data) {
      keywords = data[txt];
      score = computeInterestScore(txt, keywords, profile);
      result[txt] = score;
    }
    return result;
  };

  sortScoredData = function(scoredData) {
    var i, k, tmp, v, _i, _len, _results;
    tmp = (function() {
      var _results;
      _results = [];
      for (k in scoredData) {
        v = scoredData[k];
        _results.push([k, 1 + v]);
      }
      return _results;
    })();
    tmp.sort(function(a, b) {
      return b.v - a.v;
    });
    _results = [];
    for (_i = 0, _len = tmp.length; _i < _len; _i++) {
      i = tmp[_i];
      _results.push({
        txt: i[0],
        score: i[1] - 1
      });
    }
    return _results;
  };

  userFeedback = function(txt, keywords, feedback) {
    var choice;
    console.log(" --> " + (pretty(txt)) + " (MORE) (LESS)");
    choice = Math.round(Math.random() * 2 - 1);
    return wait(100)(function() {
      return feedback(txt, keywords, choice);
    });
  };

  rawData = ["Visit the NYC museum using your tablet", "How to brew your own coffee", "Google to launch a new museum app", "Apple to sue Microsoft"];

  database = createDatabaseFromDataset(trainingDataset);

  console.log(pretty(database));

  enrichedData = enrichData(database, rawData, true);

  console.log("initial enriched data: " + pretty(enrichedData));

  profile = {};

  scoredData = computeScores(database, enrichedData, profile);

  console.log("initial scored data: " + pretty(scoredData));

  mode = 'random';

  seen = {};

  (simulation = function() {
    var keys, keywords, topData, txt;
    console.log("update the profile <--> feed link..");
    scoredData = computeScores(database, enrichedData, profile);
    console.log("scored data: " + pretty(scoredData));
    topData = sortScoredData(scoredData);
    console.log("top feeds: " + pretty(topData));
    keywords = [];
    txt = "";
    if (mode === 'random') {
      console.log("RANDOM");
      keys = Object.keys(enrichedData);
      txt = keys[Math.round(Math.random() * (keys.length - 1))];
      keywords = enrichedData[txt];
      console.log("keywords: :::: " + pretty(keywords));
    } else if (mode === 'recommended') {
      console.log("RECOMMENDED");
    }
    console.log("txt: " + txt + "  keywords: " + keywords);
    if (!txt) {
      console.log("nothing to show");
      wait(100)(simulation);
      return;
    }
    userFeedback(txt, keywords, function(txt, keywords, choice) {
      var choiceStr, value, word, _results;
      choiceStr = {
        '1': 'LIKE',
        '-1': 'DISLIKE',
        '0': 'IGNORE'
      }[choice.toString()];
      console.log(" <-- user choose to " + choiceStr);
      if (choice === 0) {
        console.log("do nothing for " + pretty(txt));
        return;
      }
      _results = [];
      for (word in keywords) {
        value = keywords[word];
        if (!(word in profile)) {
          profile[word] = {
            weight: 0,
            count: 0
          };
        }
        profile[word].weight += choice;
        _results.push(profile[word].count += 1);
      }
      return _results;
    });
    return wait(200)(simulation);
  })();

}).call(this);
